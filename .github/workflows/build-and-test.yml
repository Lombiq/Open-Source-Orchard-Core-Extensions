name: Build and Test

# Runs for PRs opened for any branch, and pushes to the dev branch.
on:
  pull_request:
  push:
    branches:
      - dev

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true

defaults:
  run:
    shell: pwsh

jobs:
  build-and-test:
    runs-on: ${{ matrix.os }}
    name: Build and Test
    strategy:
      matrix:
        directory: ['.', 'NuGetTest']
        os: [ubuntu-latest, windows-latest]
    timeout-minutes: 60
    steps:
    - uses: actions/checkout@v2
      with:
        submodules: 'recursive'

    - name: Setup .NET Core 6.0
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 6.0.*

    - name: Build and Static Code Analysis
      working-directory: ${{ matrix.directory }}
      run: |
        npm install pnpm -g

        if (Test-Path src/Utilities/Lombiq.Gulp.Extensions/Lombiq.Gulp.Extensions.csproj)
        {
            dotnet build src/Utilities/Lombiq.Gulp.Extensions/Lombiq.Gulp.Extensions.csproj --configuration Release
        }

        $buildSwitches = @(
            '--configuration',
            'Release',
            '-warnaserror',
            '-p:TreatWarningsAsErrors=true',
            '-p:RunAnalyzersDuringBuild=true',
            '-nologo',
            '-consoleLoggerParameters:NoSummary',
            '-verbosity:quiet'
        )

        dotnet build (Get-ChildItem *.sln).FullName @buildSwitches

    - name: Set up SQL Server
      run: |
        if ($Env:RUNNER_OS -eq "Windows")
        {
            choco install sql-server-express --no-progress
        }
        else
        {
            docker pull mcr.microsoft.com/mssql/server &&
            docker run --name sql2019 -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=Password1!' -p 1433:1433 -d 'mcr.microsoft.com/mssql/server:2019-latest' &&
            docker exec -u 0 sql2019 bash -c 'mkdir /data; chmod 777 /data -R; chown mssql:root /data'
        }

    # Needs to be a separate step, otherwise the Chocolatey installation won't be visible.
    - name: Wait for SQL Server to start
      run: |
        $maxTryCount = 10

        for ($i = 1; $i -le $maxTryCount; $i++)
        {
            echo "Waiting for SQL Server to start. Attempt $i/$maxTryCount."

            if ($Env:RUNNER_OS -eq "Windows")
            {
                sqlcmd -b -S .\SQLEXPRESS -Q "SELECT @@SERVERNAME as ServerName" 2>&1>$null
            }
            else
            {
                sqlcmd -b -U sa -P 'Password1!' -Q "SELECT @@SERVERNAME as ServerName" 2>&1>$null
            }

            if ($?)
            {
                echo "SQL Server is successfully started."
                Exit 0
            }

            if ($i -eq $maxTryCount)
            {
                echo "SQL Server couldn't be started."
                Exit 1
            }

            echo "SQL Server is not ready. Waiting 1 second."
            Start-Sleep -s 1
        }

    - name: Set up Azurite via NPM
      # This needs to run in bash for some reason. Azurite properly starts in PS but still, connections fail.
      shell: bash
      run: |
        npm install -g azurite
        azurite --silent --location ${{matrix.directory}}/azurite --debug ${{matrix.directory}}/azurite/debug.log &

    # First we globally set test configurations using environment variables. Then acquire the list of all test projects
    # (excluding the two test libraries) and then runs each until one fails or all concludes. If a test fails the output
    # is sanitized from unnecessary diagnostics messages from chromedriver if the output doesn't already contain
    # groupings then it wraps them in '::group::<project name>'. If there are already groupings, then this is not
    # possible to nest them (https://github.com/actions/runner/issues/802) so that's omitted. The groupings make the
    # output collapsible region on the Actions web UI.
    # Note: on Windows any output will be wrapped to 120 columns (the default buffer width) when we output into a
    # temporary variable. We can't change the assumed column count as that would normally happen via
    # [Console]::BufferWidth but interacting with this variable results in a "The handle is invalid." exception because
    # the output is already redirected into GitHub. This can't be helped.
    - name: Tests
      working-directory: ${{ matrix.directory }}
      run: |
        function Configure-Environment($hash) { Set-Item @hash }

        if ($Env:RUNNER_OS -eq "Windows")
        {
            Configure-Environment @{
                Path = 'Env:\Lombiq_Tests_UI__SqlServerDatabaseConfiguration__ConnectionStringTemplate'
                Value = 'Server=.\\SQLEXPRESS;Database=LombiqUITestingToolbox_{{id}};Integrated Security=True;MultipleActiveResultSets=True;Connection Timeout=60;ConnectRetryCount=15;ConnectRetryInterval=5'
            }
        }
        else
        {
            Configure-Environment @{
                Path = 'Env:\Lombiq_Tests_UI__SqlServerDatabaseConfiguration__ConnectionStringTemplate'
                Value = 'Server=.;Database=LombiqUITestingToolbox_{{id}};User Id=sa;Password=Password1!;MultipleActiveResultSets=True;Connection Timeout=60;ConnectRetryCount=15;ConnectRetryInterval=5'
            }
            Configure-Environment @{
                Path = 'Env:\Lombiq_Tests_UI__DockerConfiguration__ContainerName'
                Value = 'sql2019'
            }
        }

        $tests = dotnet sln list |
            Select-Object -Skip 2 |
            Select-String '\.Tests\.' |
            Select-String -NotMatch 'Lombiq.Tests.UI.csproj' |
            Select-String -NotMatch 'Lombiq.Tests.csproj' |
            ? {
                $result =  (dotnet test --no-restore --list-tests --verbosity quiet $_ 2>&1) -join [System.Environment]::NewLine
                -not [string]::IsNullOrEmpty($result) -and $result.Contains('The following Tests are available')
            }

        foreach ($test in $tests) {
            $result = (dotnet test -c Release --no-restore --no-build --nologo --verbosity quiet $test)

            if ($?)
            {
                echo "Test Successful: $test"
                continue
            }

            $needsGrouping = -not $result.Contains('::group::')

            if ($needsGrouping) { echo "::group::$test" }

            echo $result |
                Select-String -NotMatch 'Connection refused \[::ffff:127.0.0.1\]' |
                Select-String -NotMatch 'ChromeDriver was started successfully'

            if ($needsGrouping) { echo "::endgroup::" }

            exit 1
        }

    # Note that this will fail under Windows if the path is too long, regardless of LongPathsEnabled, see:
    # https://github.com/actions/upload-artifact/issues/309. We can't do much about this apart from uploading artifacts
    # in a low-level way.
    - name: Upload artifacts
      uses: actions/upload-artifact@v3
      # Needs to be always() so if there's a failure dump, it'll be uploaded even if with retries the tests passed.
      if: always() && hashFiles(format('{0}/test/**/FailureDumps', matrix.directory))
      with:
        name: ui-test-failure-dump-${{ matrix.directory }}-${{ matrix.os }}
        path: ${{ matrix.directory }}/test/**/FailureDumps/
        if-no-files-found: ignore
